# 2023-09-17 (日曜日)

* 達人プログラマーを一通り読んだ
  * その結果、深掘りしたいことが生まれたので別セクションでまとめる
* 自分が現在どの地点にいて、見える範囲で最良の手は何かを常に考えると、どんなことでもできるようになりそう

## 達人プログラマーで知りたいこと

* 直行性ってなんだろう？具体的にはどうすれば直行性を実現できる？
  * コンピューティングの分野では結合度の低さを表している
    * つまり、片方を変更してももう片方に影響を与えないことである
  * 具体的には、UIの変更がDBスキーマに影響与えないことなど
  * ざっくり言えば、直行しているシステムはここの要素の影響範囲が小さいので変更しやすいということっぽいね
  * どうやら階層化アプローチをとるようにするといいらしい
    * 各階層ではその下の階層が提供する**抽象**のみを利用する
    ```
    -----------------------------
    |UI                         |
    -----------------------------
    |DBアクセス|認証|業務ロジック   |
    -----------------------------
    |アプリケーションフレームワーク  |
    |           ----------------
    |           |標準ライブラリ   |
    ----------------------------
    |コンテナサービス             |
    ----------------------------
    ```

* プロトタイプって曳光弾とは何が違う？それぞれの使い分けは？
  * 曳光弾は本物の弾丸と同じ条件で発射されるためフィードバックを得るのに効果的である
  * →つまり曳光弾方開発も実運用時と同じ条件で行うことで適切なフィードバックを即座に受けることができる
  * 要するに常にデモを行える環境があるということ
  * 曳光弾は、インクリメンタルなアプローチであり、要求が常に変化していく前提で進めていくようなものになっている
  * それに対し「プロトタイピング」はシステムの最終形態が持つ特定の側面について探究するためのものになっている
    * 例えば、UIという特定の側面に対し、最終的に進むべき方向を探究するために使ったりする
    * あくまで確認用であり、それを破棄して作り直す必要がある部分が曳光弾とは違う
  * 端的にまとめると以下である
    * 曳光弾→ミニマムだが完全なもので最終的なシステムの骨格を構成するもの
    * プロトタイピング→使い捨てのもの
      * こっちは曳光弾の前に行う工程のイメージ（諜報活動など）

* 相続税を払わないために、インターフェースを愛用する必要があるのはなぜ？どうやら継承は使わない方がいいっぽい？
  * 継承は結合であるため、親の親とも結合されることとなる
    * →祖先の変更自体はトップレベルのコードからは検知できないので、壊れたコードの気づかずに使う可能性がある
    ```
    class Animal(volume)
      self.volume = volume # ここのインスタンス変数をsoundに変えると、コードは壊れる

      def cry(volume):
        self.volume = volume
    
    class Dog(Animal):
      def info():
        print("私の声の大きさは${self.volume}です")

    # top-level code
    dog = new Dog()
    dog.cry(100)
    ```
    * インターフェースを使えば、ポリモーフィズムを継承を使わずに（つまり強い結合を回避して）実現することができる
    ```
    public class Dog implements Cryable, Runnable {

    }

    public interface Cryable {
      
    }

    public interface Runnable {
      
    }
    ```
      * クライアントコード側では直接Dogクラスを指定することなく、インターフェースを指定することが可能なので、仮にdog以外のCryableなクラスを同じコレクションに入れたい場合にも対応可能
      * ~~またインターフェース間は直交しているので、インターフェースの組み合わせにより様々なクラスを実現することができそう~~ この考えはmixinの方が適切かもしれない
        * これは継承を使っている場合だと、多重継承ができない影響で不可能だったと思う
          * e.g. dogにはAnimalという側面と、Partnerという側面があるが多重継承が不可である以上、継承を無理に使おうとするとDRYの原則から外れたコードを書くしかなくなる
      * 

* 共有状態によって並行性にもたらす危険と、その解消方法はどんなものになる？
  * 2人のウェイターがそれぞれ別の客から同時に残り1つのパイの注文を受けるような状況を考える
    * この場合、パイが入っているケースは共有されており、ウェイターの注文は並行に受けられるので、どちらかの客がパイがあると聞いて注文したのに、パイを受け取ることができないという問題が発生する
  * セマフォーというある時点で誰か1人しか占有できないものを用意することで共有状態の問題を解消する
    * つまり、セマフォーを占有していない処理は、セマフォーを占有できるまで待つので状態の競合が起きない

* 偶発的プログラミングをすると、自分で書いたコードがなぜ動くのかを説明できなくなるらしいが、具体的にどうすれば回避できるの？
  * まず偶発的プログラミングは、幸運と行き当たりばったりの成功に頼るようなプログラミングで、たまたま地雷を踏まないことで誤った結論に導かれるような危険なもの
  * 以下のことを心がけると回避できそう
    * 他の場所からコードを流用する際に、そのコードが本当に同じコンテキストなのかを自問する
    * 信頼のおける物事だけを前提する
    * 仮定を置かなければならない状況になった場合にはドキュメント化する
      * また仮定も表明を用いて実際にテストしてみる（e.g. idにnullはないという前提が正しいかをassertでチェックする）


# 2023-09-18 (月曜日)

* 達人プログラマーの掘り下げができてなかったのでやった
  * 内容は上にまとめた
  * 特にインターフェースとmixinの違いが面白かった
* 朝5:30くらいからジムにいって運動すると、眠い
  * ただ継続していくと良い習慣になりそう
* 



# 2023-09-19 (火曜日)



# 2023-09-20 (水曜日)



# 2023-09-21 (木曜日)



# 2023-09-22 (金曜日)



# 2023-09-23 (土曜日)



